Q1>
### [260\. Single Number III](https://leetcode.com/problems/single-number-iii/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Bit Manipulation](https://leetcode.com/tag/bit-manipulation/)


Given an integer array `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in **any order**.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

**Example 1:**

```
Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
```

**Example 2:**

```
Input: nums = [-1,0]
Output: [-1,0]
```

**Example 3:**

```
Input: nums = [0,1]
Output: [1,0]
```

**Constraints:**

*   `2 <= nums.length <= 3 * 10<sup>4</sup>`
*   `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`
*   Each integer in `nums` will appear twice, only two integers will appear once.


#### Solution

Language: **C++**

```c++
class Solution {
public:
    
    bool checkBit(int n,int i)
    {
        return (n >> i)&1;
    }
    vector<int> singleNumber(vector<int>& nums) {
        // 10: 00 pm
        int twonum = 0;
        for(int i : nums)
        {
            twonum ^= i;
        }
        int pos=-1;
        
        for(int i=0; i <= 32 ; i++)
        {
            if(checkBit(twonum,i))
            {
                pos = i;
                break;
            }
        }
        int num1=0,num2=0;
        
        for(int j=0; j <= 32; j++)
        {
            for(int i=0; i < nums.size(); i++)
            {
                if(checkBit(nums[i],pos))
                    num1 ^= nums[i];
                else
                    num2 ^= nums[i];                
            }
        }
        
        vector<int> ans;
        ans.push_back(num1);
        ans.push_back(num2);
        
        
        return ans;
        
    }
};
```
