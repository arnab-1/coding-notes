Q 1:>>
Q3. Array with consecutive elements
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given an array of positive integers A, check and return whether the array elements are consecutive or not.
NOTE: Try this with O(1) extra space.



Problem Constraints
1 <= length of the array <= 100000
1 <= A[i] <= 10^9



Input Format
The only argument given is the integer array A.



Output Format
Return 1 if the array elements are consecutive else return 0.



Example Input
Input 1:

 A = [3, 2, 1, 4, 5]
Input 2:

 A = [1, 3, 2, 5]


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 As you can see all the elements are consecutive, so we return 1.
Explanation 2:

 Element 4 is missing, so we return 0.
 
 
 Solution :
 int Solution::solve(vector<int> &A) {
    // 3 min 
    if(A.size() == 1)
    return 1;
    sort(A.begin(),A.end());

    for(int i=0; i < A.size()-1 ; i++)
    {
        if(A[i]+1 != A[i+1])
        return 0;
    }

    return 1;
}


///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Q2>
### [945\. Minimum Increment to Make Array Unique](https://leetcode.com/problems/minimum-increment-to-make-array-unique/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/), [Counting](https://leetcode.com/tag/counting/)


You are given an integer array `nums`. In one move, you can pick an index `i` where `0 <= i < nums.length` and increment `nums[i]` by `1`.

Return _the minimum number of moves to make every value in_ `nums` _**unique**_.

**Example 1:**

```
Input: nums = [1,2,2]
Output: 1
Explanation: After 1 move, the array could be [1, 2, 3].
```

**Example 2:**

```
Input: nums = [3,2,1,2,1,7]
Output: 6
Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `0 <= nums[i] <= 10<sup>5</sup>`


#### Solution

Language: **C++**

```c++
class Solution {
public:
    int minIncrementForUnique(vector<int>& nums) {
        // 1 1 2 2 3 7
        // 1 2 3 4 5 7
        sort(nums.begin(),nums.end());
        
        int count = 0;
        for(int i=0; i < nums.size() - 1 ; i++)
        {
            if(nums[i] == nums[i+1] || (nums[i] > nums[i+1]) )
            {
                int t = nums[i+1];
                nums[i+1] = nums[i]+1;
                count += (nums[i+1]- t);
            }
        }
        return count;
    }
};
```


///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\



