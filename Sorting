Q 1:>>
Q3. Array with consecutive elements
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given an array of positive integers A, check and return whether the array elements are consecutive or not.
NOTE: Try this with O(1) extra space.

Problem Constraints
1 <= length of the array <= 100000
1 <= A[i] <= 10^9



Input Format
The only argument given is the integer array A.



Output Format
Return 1 if the array elements are consecutive else return 0.



Example Input
Input 1:

 A = [3, 2, 1, 4, 5]
Input 2:

 A = [1, 3, 2, 5]


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 As you can see all the elements are consecutive, so we return 1.
Explanation 2:

 Element 4 is missing, so we return 0.
 
 
 Solution :
 int Solution::solve(vector<int> &A) {
    // 3 min 
    if(A.size() == 1)
    return 1;
    sort(A.begin(),A.end());

    for(int i=0; i < A.size()-1 ; i++)
    {
        if(A[i]+1 != A[i+1])
        return 0;
    }

    return 1;
}


///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Q2>
### [945\. Minimum Increment to Make Array Unique](https://leetcode.com/problems/minimum-increment-to-make-array-unique/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/), [Counting](https://leetcode.com/tag/counting/)


You are given an integer array `nums`. In one move, you can pick an index `i` where `0 <= i < nums.length` and increment `nums[i]` by `1`.

Return _the minimum number of moves to make every value in_ `nums` _**unique**_.

**Example 1:**

```
Input: nums = [1,2,2]
Output: 1
Explanation: After 1 move, the array could be [1, 2, 3].
```

**Example 2:**

```
Input: nums = [3,2,1,2,1,7]
Output: 6
Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `0 <= nums[i] <= 10<sup>5</sup>`


#### Solution

Language: **C++**

```c++
class Solution {
public:
    int minIncrementForUnique(vector<int>& nums) {
        // 1 1 2 2 3 7
        // 1 2 3 4 5 7
        sort(nums.begin(),nums.end());
        
        int count = 0;
        for(int i=0; i < nums.size() - 1 ; i++)
        {
            if(nums[i] == nums[i+1] || (nums[i] > nums[i+1]) )
            {
                int t = nums[i+1];
                nums[i+1] = nums[i]+1;
                count += (nums[i+1]- t);
            }
        }
        return count;
    }
};
```


///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Q4 : 
Q1. Chocolate Distribution
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given an array A of N integers where each value represents number of chocolates in a packet.

i-th can have A[i] number of chocolates.

There are B number students, the task is to distribute chocolate packets following below conditions:

1. Each student gets one packet.
2. The difference between the number of chocolates in packet with maximum chocolates and packet with minimum chocolates given to the students is minimum.
Return the minimum difference (that can be achieved) between maximum and minimum number of chocolates distributed.



Problem Constraints
0 <= N <= 10^5
1 <= A[i] <= 10^7
0 <= B <= 10^5


Input Format
The first argument contains an integer array A.

The second argument contains an integer B.



Output Format
Return the minimum difference (that can be achieved) between maximum and minimum number of chocolates distributed.


Example Input
Input:

  A : [3, 4, 1, 9, 56, 7, 9, 12]
  B : 5


Example Output
Output:

  6


Example Explanation
Explanation:

  Minimum Difference is 6
  The set goes like 3,4,7,9,9 and the output is 9-3 = 6
  
  
  Solution:
  
  int Solution::solve(vector<int> &A, int B) {
    // 1 hr 10 min
    sort(A.begin(),A.end());
    int n = A.size();
    if(n < B || B==0)
    return 0;
    int ans = INT_MAX;
    for(int i=0 ; i < n-B ; i++)
    {
        ans = min(ans, A[i+B-1] - A[i]);
    }
    return ans;
}

///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Q51>


Q1. MaxMod
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given an array A of size N, groot wants you to pick 2 indices i and j such that

1 <= i, j <= N
A[i] % A[j] is maximum among all possible pairs of (i, j).
Help Groot in finding the maximum value of A[i] % A[j] for some i, j.



Problem Constraints
1 <= N <= 100000
0 <= A[i] <= 100000



Input Format
First and only argument in an integer array A.



Output Format
Return an integer denoting the maximum value of A[i] % A[j] for any valid i, j.



Example Input
Input 1:

 A = [1, 2, 44, 3]
Input 2:

 A = [2, 6, 4]


Example Output
Output 1:

 3
Output 2:

 4


Example Explanation
Explanation 1:

 For i = 3, j = 2  A[i] % A[j] = 3 % 44 = 3.
 No pair exists which has more value than 3.
Explanation 2:

 For i = 2, j = 1  A[i] % A[j] = 4 % 6 = 4.
 

int Solution::solve(vector<int> &A) {
    //15 min

    int max1 ,max2;
    max1 = max2 = 0;
    if(A.size() == 1)
    return A[0];

    sort(A.begin(),A.end());

    for(int i : A)
    {
       if(i > max1)
       {
            max2 = max1;
           max1 = i;
           
       }
    }

    return max2 % max1;
}


///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

### [169\. Majority Element](https://leetcode.com/problems/majority-element/)

Difficulty: **Easy**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Hash Table](https://leetcode.com/tag/hash-table/), [Divide and Conquer](https://leetcode.com/tag/divide-and-conquer/), [Sorting](https://leetcode.com/tag/sorting/), [Counting](https://leetcode.com/tag/counting/)


Given an array `nums` of size `n`, return _the majority element_.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

**Example 1:**

```
Input: nums = [3,2,3]
Output: 3
```

**Example 2:**

```
Input: nums = [2,2,1,1,1,2,2]
Output: 2
```

**Constraints:**

*   `n == nums.length`
*   `1 <= n <= 5 * 10<sup>4</sup>`
*   `-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1`

**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?

#### Solution

Language: **C++**

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        //15 min
        if(nums.size() == 1)
            return nums[0];
        unordered_map<int,int> hm;
        for(int i : nums)
        {
            if(hm.find(i) != hm.end())
            hm[i]++;
            else
                hm.insert({i,1});
        }
        
        int count = INT_MIN,ans;
        for(auto i  : hm)
        {
         //   ans = max(count,hm[i]);
            {
                if(count < i.second)
                {
                    ans = i.first;
                    count = i.second;
                }
            }
        }
        
        return ans;
    }
};
`

///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
