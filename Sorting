Q 1:>>
Q3. Array with consecutive elements
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given an array of positive integers A, check and return whether the array elements are consecutive or not.
NOTE: Try this with O(1) extra space.



Problem Constraints
1 <= length of the array <= 100000
1 <= A[i] <= 10^9



Input Format
The only argument given is the integer array A.



Output Format
Return 1 if the array elements are consecutive else return 0.



Example Input
Input 1:

 A = [3, 2, 1, 4, 5]
Input 2:

 A = [1, 3, 2, 5]


Example Output
Output 1:

 1
Output 2:

 0


Example Explanation
Explanation 1:

 As you can see all the elements are consecutive, so we return 1.
Explanation 2:

 Element 4 is missing, so we return 0.
 
 
 Solution :
 int Solution::solve(vector<int> &A) {
    // 3 min 
    if(A.size() == 1)
    return 1;
    sort(A.begin(),A.end());

    for(int i=0; i < A.size()-1 ; i++)
    {
        if(A[i]+1 != A[i+1])
        return 0;
    }

    return 1;
}


///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Q2>
### [945\. Minimum Increment to Make Array Unique](https://leetcode.com/problems/minimum-increment-to-make-array-unique/)

Difficulty: **Medium**  

Related Topics: [Array](https://leetcode.com/tag/array/), [Greedy](https://leetcode.com/tag/greedy/), [Sorting](https://leetcode.com/tag/sorting/), [Counting](https://leetcode.com/tag/counting/)


You are given an integer array `nums`. In one move, you can pick an index `i` where `0 <= i < nums.length` and increment `nums[i]` by `1`.

Return _the minimum number of moves to make every value in_ `nums` _**unique**_.

**Example 1:**

```
Input: nums = [1,2,2]
Output: 1
Explanation: After 1 move, the array could be [1, 2, 3].
```

**Example 2:**

```
Input: nums = [3,2,1,2,1,7]
Output: 6
Explanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
```

**Constraints:**

*   `1 <= nums.length <= 10<sup>5</sup>`
*   `0 <= nums[i] <= 10<sup>5</sup>`


#### Solution

Language: **C++**

```c++
class Solution {
public:
    int minIncrementForUnique(vector<int>& nums) {
        // 1 1 2 2 3 7
        // 1 2 3 4 5 7
        sort(nums.begin(),nums.end());
        
        int count = 0;
        for(int i=0; i < nums.size() - 1 ; i++)
        {
            if(nums[i] == nums[i+1] || (nums[i] > nums[i+1]) )
            {
                int t = nums[i+1];
                nums[i+1] = nums[i]+1;
                count += (nums[i+1]- t);
            }
        }
        return count;
    }
};
```


///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Q4 : 
Q1. Chocolate Distribution
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given an array A of N integers where each value represents number of chocolates in a packet.

i-th can have A[i] number of chocolates.

There are B number students, the task is to distribute chocolate packets following below conditions:

1. Each student gets one packet.
2. The difference between the number of chocolates in packet with maximum chocolates and packet with minimum chocolates given to the students is minimum.
Return the minimum difference (that can be achieved) between maximum and minimum number of chocolates distributed.



Problem Constraints
0 <= N <= 10^5
1 <= A[i] <= 10^7
0 <= B <= 10^5


Input Format
The first argument contains an integer array A.

The second argument contains an integer B.



Output Format
Return the minimum difference (that can be achieved) between maximum and minimum number of chocolates distributed.


Example Input
Input:

  A : [3, 4, 1, 9, 56, 7, 9, 12]
  B : 5


Example Output
Output:

  6


Example Explanation
Explanation:

  Minimum Difference is 6
  The set goes like 3,4,7,9,9 and the output is 9-3 = 6
  
  
  Solution:
  
  int Solution::solve(vector<int> &A, int B) {
    // 1 hr 10 min
    sort(A.begin(),A.end());
    int n = A.size();
    if(n < B || B==0)
    return 0;
    int ans = INT_MAX;
    for(int i=0 ; i < n-B ; i++)
    {
        ans = min(ans, A[i+B-1] - A[i]);
    }
    return ans;
}

///////////////////////////////////////////////////////////////******************************************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Q51>





