Q1:
Q1. Single Element in a Sorted Array
Solved
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given a sorted array of integers A where every element appears twice except for one element which appears once, find and return this single element that appears only once.

NOTE: Users are expected to solve this in O(log(N)) time.



Problem Constraints

1 <= |A| <= 100000

1 <= A[i] <= 10^9



Input Format

The only argument given is the integer array A.



Output Format

Return the single element that appears only once.



Example Input

Input 1:

A = [1, 1, 7]
Input 2:

A = [2, 3, 3]


Example Output

Output 1:

 7
Output 2:

 2


Example Explanation

Explanation 1:

 7 appears once
Explanation 2:

 2 appears once
 
 
 Solution:
 
 int Solution::solve(vector<int> &A) {
    int ans =0;
    int n = A.size();
    if(n==1)
    return A[0];

    if(A[n-1] != A[n-2])
    return A[n-1];

    if(A[0] != A[1])
    return A[0];
    int l=1,h=A.size()-1-1;

    while(l<=h)
    {
        int m = (l+h)/2;
        if(A[m] != A[m-1] and A[m] != A[m+1])
        return A[m];
        else if(m%2 == 0 and A[m] == A[m+1] || m%2 == 1  and A[m]==A[m-1])
        l = m+1;
        else
        h = m-1;
    }
}
////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Q3. Sorted Insert Position
Solved
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given a sorted array A of size N and a target value B, return the index (0-based indexing) if the target is found.
If not, return the index where it would be if it were inserted in order.

NOTE: You may assume no duplicates in the array. Users are expected to solve this in O(log(N)) time.



Problem Constraints

1 <= N <= 106



Input Format

First argument is an integer array A of size N.
Second argument is an integer B.



Output Format

Return an integer denoting the index of target value.



Example Input

Input 1:

A = [1, 3, 5, 6]
 B = 5
Input 2:

A = [1]
 B = 1


Example Output

Output 1:

2
Output 2:

0


Example Explanation

Explanation 1:

The target value is present at index 2.
Explanation 2:

The target value is present at index 0.


int Solution::searchInsert(vector<int> &A, int B) {
    // 11:54 pm
    int l = 0, h = A.size()-1;
    while(l <= h)
    {
        int m = (l+h)/2;
        if(A[m] == B)
        return m;
        else if(A[m] < B)
        l = m + 1;
        else 
        h = m-1;
    }
    return l;
}



////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

Q2. Search for a Range
Solved
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description
Given a sorted array of integers A(0 based index) of size N, find the starting and ending position of a given integar B in array A.

Your algorithm's runtime complexity must be in the order of O(log n).

Return an array of size 2, such that first element = starting position of B in A and second element = ending position of B in A, if B is not found in A return [-1, -1].



Problem Constraints
1 <= N <= 106

1 <= A[i], B <= 109



Input Format
The first argument given is the integer array A.
The second argument given is the integer B.



Output Format
Return an array of size 2, such that first element = starting position of B in A and second element = ending position of B in A, if B is not found in A return [-1, -1].



Example Input
Input 1:

 A = [5, 7, 7, 8, 8, 10]
 B = 8
Input 2:

 A = [5, 17, 100, 111]
 B = 3


Example Output
Output 1:

 [3, 4]
Output 2:

 [-1, -1]


Example Explanation
Explanation 1:

 First occurence of 8 in A is at index 3
 Second occurence of 8 in A is at index 4
 ans = [3, 4]
Explanation 2:

 There is no occurence of 3 in the array.
 
 
 
 
int left(const vector<int> &A,int B)
{
    int l = 0,h = A.size()-1,ans = -1;
    while(l <= h)
    {
        int m = (l+h)/2;
        if(A[m] == B)
        {
            ans = m;
            h = m-1;
        }
        else if(A[m] > B)
        h = m-1;
        else
        l = m+1;
    }

    return ans;
}

int right(const vector<int> &A,int B)
{
    int l = 0, h = A.size()-1,ans = -1;
    while( l <= h)
    {
        int m = (l+h)/2;
        if(A[m] == B)
        {
            ans = m;
            l = m+1;
        }
        else if(A[m] > B)
        h = m-1;
        else
        l = m+1;
    }

    return ans;
}
vector<int> Solution::searchRange(const vector<int> &A, int B) {
    //11:34 am
    int n = A.size();
    int l = left(A,B);
    int r = right(A,B);

    vector<int> ans;
    
    ans.push_back(l);
    ans.push_back(r);
    return ans;
}


////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Q1. Rotated Sorted Array Search
Solved
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Given a sorted array of integers A of size N and an integer B.

array A is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2 ).

You are given a target value B to search. If found in the array, return its index, otherwise return -1.

You may assume no duplicate exists in the array.

NOTE: Users are expected to solve this in O(log(N)) time.



Problem Constraints

1 <= N <= 1000000

1 <= A[i] <= 10^9

all elements in A are disitinct.



Input Format

The first argument given is the integer array A.

The second argument given is the integer B.



Output Format

Return index of B in array A, otherwise return -1



Example Input

Input 1:

A = [4, 5, 6, 7, 0, 1, 2, 3]
B = 4
Input 2:

A = [1]
B = 1


Example Output

Output 1:

 0
Output 2:

 0


Example Explanation

Explanation 1:

 
Target 4 is found at index 0 in A.
Explanation 2:

 
Target 1 is found at index 0 in A.


int pivot(const vector<int> &A)
{
    int l = 0, h = A.size()-1, k = 0;
    while(l <= h)
    {
        int m = (l+h)/2;
        if(A[0] < A[m])
        {
             l = m + 1 ;
        }
        else 
      h = m-1;
    }

    return l;
}

int bs(const vector<int> &A,int B,int l,int h)
{
    while(l <= h)
    {
        int m = (l+h)/2;
        if(A[m] == B)
        return m;
        else if(A[m] < B)
        l = m + 1;
        else
        h = m-1;
    }
    return -1;
}
int Solution::search(const vector<int> &A, int B) {
    

    int p = pivot(A);
 //   p--;
    int l = bs(A,B,0,p-1);
    int r  = bs(A,B,p,A.size()-1);
    if(l == -1)
    return r;
    else
    return l;


}


////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
Q1. Aggressive cows
Solved
character backgroundcharacter
Stuck somewhere?
Ask for help from a TA & get it resolved
Get help from TA
Problem Description

Farmer John has built a new long barn, with N stalls. Given an array of integers A of size N where each element of the array represents the location of the stall, and an integer B which represent the number of cows.

His cows don't like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, John wants to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?



Problem Constraints

2 <= N <= 100000
0 <= A[i] <= 109
2 <= B <= N



Input Format

The first argument given is the integer array A.
The second argument given is the integer B.



Output Format

Return the largest minimum distance possible among the cows.



Example Input

Input 1:

A = [1, 2, 3, 4, 5]
B = 3
Input 2:

A = [1, 2]
B = 2


Example Output

Output 1:

 2
Output 2:

 1


Example Explanation

Explanation 1:

 
John can assign the stalls at location 1,3 and 5 to the 3 cows respectively.
So the minimum distance will be 2.
Explanation 2:

 
The minimum distance will be 1.


Solution : 

bool check(vector<int> &A,int B,int n)
{
    sort(A.begin(),A.end());
    int cow = 1, last = A[0];
    for(int i = 1 ; i < A.size() ; i++)
    {
        if(A[i] - last >= n )
        {
            cow++;
            last = A[i];
        }
    }

    return (cow >= B);

}
int Solution::solve(vector<int> &A, int B) {
    //10:00 pm
    sort(A.begin(),A.end());
    int stall_count = A.size();

    int l = 1, h = A[stall_count-1]-A[0],ans;

    while(l <= h)
    {
        int m = (l+h)/2;
        if(check(A,B,m))
        {
            ans = m;
            l = m+1;
        }
        else
        h = m - 1;
    }

    return ans;
}

////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\




////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\




////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\





////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\






////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\





////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\






////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\








////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\





////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\







////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\








////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\





////////////////////////////////////////////////////////////////////*******************\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
